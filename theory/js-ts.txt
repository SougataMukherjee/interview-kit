=======================
JAVASCRIPT THEORY NOTES
=======================

Q1: what is JavaScript? why name called JavaScript?
JavaScript is a lightweight, case sensitive scripting language.
JS was created to add logic to web pages;  initial name was "LiveScript" then marketing—syntax inspired by Java, but not related.

Q2: what are JavaScript engine?
a javascript engine is a computer programme that execute javascript code developed by web browser vender.
Example: chrome we have V8 firefox we have SpiderMonkey

Q3: JavaScript vs ECMAScript
JavaScript → language used in browsers.
ECMAScript → standard/spec that JS follows.

Q4: What is Hoisting?
Variables and functions are moved to top of scope during compilation.
Example:
console.log(a); // undefined
var a = 5;

function foo(){
  console.log(a);//undefined
  var a =5;
}
foo()

Q5: What is Closure?
inner function remembers parent scope even after function ends.
Example:
function outer() {
  let count = 0;
  return function inner() {
    count++;
    console.log(count);
  }
}

Q6: Difference: var, let, const
var -> function scoped, can be redeclared and hoisted with undefined
let, const -> block scoped,let cannot be reassigned but const cannot be reassigned.
function demo() {
  if (true) {
    var x = 10;
    let y = 20;
    const z = 30;
  }
  console.log(x); // ✅ works (var → function scope)
  console.log(y); // ❌ error (let → block scope)
  console.log(z); // ❌ error (const → block scope)
}
demo();

Q7: What is Event Loop?
Handles async operations. Executes sync code first, then callbacks from queue.
Example:
console.log("a");
setTimeout(() => {
  console.log("b");
  setTimeout(() => {
    console.log("c");
  }, 1000);

}, 1000);
console.log("d");

// Output: a d b c

Q8:Sync vs Async
Sync → one by one
Async → doesn’t block next

Q9: What is 'this' keyword?
Refers to current context.
In function -> global/window
In object -> that object.

Q10: Arrow function vs normal function vs IIFE vs Anonymous function
Normal Function function add(a, b) { return a + b; }
Arrow Function  const add = (a, b) => a + b;
IIFE (Immediately Invoked Function Expression) (function(){ console.log("Run once"); })();
Anonymous Function let f=function(args){}

Q11: Shallow vs Deep Copy
Shallow: Copies only the top-level values.
If the object contains another object, only the reference is copied, not the actual nested data.
So changing nested values affects both copies.
Deep: Creates a completely independent copy of all levels of the object.
Changing nested values does not affect the original.
Example:
Original Object
a → { x:1, y:{ z:2 } }

Shallow Copy:
b = { ...a }
a.y ───────► { z:2 } ◄────── b.y    (same reference)

Deep Copy:
b = JSON.parse(JSON.stringify(a))
a.y ──► { z:2 }     b.y ──► { z:2 }   (separate copies)



Q12. What are Promises?
Used to handle async operations, It has 3 states: pending → resolved → rejected
Example:
new Promise((res, rej)=>res(5)).then(console.log);

Q13. Promise.all vs Promise.race
Promise.all() → Runs multiple promises in parallel and waits until all are finished.If any one fails, the whole result fails
Promise.race() → Runs multiple promises in parallel and returns the result of the first one that finishes (success or fail)
Promise.all([P1, P2, P3])
   P1 ----✅
   P2 --------✅
   P3 ------------✅
Result → after last one finishes
Promise.race([P1, P2, P3])
   P1 ----✅  ← finishes first → return this one
   P2 --------✅
   P3 ------------✅


Q14. How to fetch API using Promise?
fetch("https://api.example.com/data")
  .then(res => res.json())
  .then(data => console.log(data))
  .catch(err => console.log(err));

Q15. create a Promise and resolve on Button click
import { useState } from "react";

export default function App() {
  function createClickPromise() {
    return new Promise((resolve) => {
      resolve("Button clicked!");
    });
  }
  function handleClick() {
    createClickPromise().then((msg) => console.log(msg));
  }
  return (
    <button onClick={handleClick}>
      Click Me
    </button>
  );
}

Q16. using promise fetch a data,if the fetch fails it should automatically retry after the given delay, up to the maximum number of attempts
function retryFetch(url, maxSteps, delay) {
  let attempt = 0;

  return new Promise((resolve, reject) => {
    function tryAgain() {
      fetch(url)
        .then(res =>res.json())
        .then(data => resolve(data))
        .catch(err => {
          attempt++;
          if (attempt < maxSteps) {
            console.log(attempt);
            setTimeout(tryAgain, delay);
          } else {
            reject("Failed");
          }
        });
    }
    tryAgain();
  });
}

retryFetch("https://dummyjson.com/posts/1", 3, 1000)
  .then(data => console.log(data))
  .catch(err => console.error(err));

How to handle error in Promise
Use .catch() or try...catch inside async/await.
fetch(url).catch(err => console.error(err));


Q17. Async/Await
Syntax sugar over Promises.
Example:
import { useEffect, useState } from "react";
function App() {
  const [data, setData] = useState(null);
  async function getData() {
    const res = await fetch("https://jsonplaceholder.typicode.com/users");
    const result = await res.json();
    setData(result);
  }
  useEffect(() => {
    getData();
  }, []);

  return (
    <div>
      <h3>Users Data</h3>
      {data && data.map(u => <p key={u.id}>{u.name}</p>)}
    </div>
  );
}
export default App;


Q18: What is Debounce & Throttle?
Debounce: delay execution till user stops typing.
Runs after user stops typing or triggering for a certain time
Useful for: Search bars, input validation, API calls

import { useState, useEffect } from "react";

export default function SearchBox() {
  const [text, setText] = useState("");

  useEffect(() => {
    const timer = setTimeout(() => {
      console.log("Searching for:", text);
    }, 500); // wait 0.5s after user stops typing
    return () => clearTimeout(timer);
  }, [text]);

  return <input onChange={(e) => setText(e.target.value)} placeholder="Search..." />;
}

Throttle: limit execution in interval.
Runs the function once every fixed time, even if triggered multiple times.
Useful for: Scroll, resize, mouse move events.

Q19: Polyfill Example (map)
Array.prototype.myMap = function(cb){
  let res=[];
  for(let i=0;i<this.length;i++){
    res.push(cb(this[i],i));
  }
  return res;
}

Q20: Call, Apply, Bind
All used to set 'this' manually.
function greet(greeting, emoji) {
  console.log(`${greeting}, ${this.name}! ${emoji}`);
}
greet.call(person, "Hi", "😊");     // Hi, Alice! 😊
greet.apply(person, ["Hello", "👋"]); // Hello, Alice! 👋
const greetAlice = greet.bind(person);
greetAlice("Hey", "😎");           // Hey, Alice! 😎

Q21: What is Currying?
Currying is the process of transforming a function that takes multiple arguments into a sequence of functions, each taking a single argument
Example:
function add(a) {
  return function(b) {
    return a + b;
  };
}
const add5 = add(5);
console.log(add5(3)); // 8


Q22: What is Prototype?
JS uses prototypal inheritance. Every object has a hidden [[Prototype]].
Objects inherit from __proto__ → links to [[Prototype]]

Q23: Difference: undefined vs null
undefined -> declared but not assigned
null -> intentional empty value.

Q24: Event Delegation
Attach single listener to parent.
Example:
ul.addEventListener('click',(e)=>{ if(e.target.tagName==='LI') console.log(e.target.textContent) })

Q25: LocalStorage vs SessionStorage with exp
localStorage -> persists after reload and permanent until cleared.
sessionStorage -> clears when tab closes

Q26: Spread vs Rest
Spread -> expands [...arr]
const nums = [1, 2, 3];
const newNums = [...nums, 4, 5]; // [1, 2, 3, 4, 5]
Rest -> collects (...args)
function sum(...args) {
  return args.reduce((a, b) => a + b, 0);
}
sum(1, 2, 3, 4);

Q27: Deep Clone Object
JSON.parse(JSON.stringify(obj));
NOTE:JSON.stringify() → Object → String
     JSON.parse() → String → Object

Q28: Optional Chaining
Access nested property safely: user?.address?.city

Q29: Difference Between == and ===
== does type coercion
=== checks type + value

Q30: Difference Between slice, splice, split
slice -> copy array portion,doesn’t change original array
splice -> modify array,change original array
 [1, 2, 3, 4, 5]
slice(1,4)  -> [2, 3, 4]   (copy only)
splice(1,3) -> [2, 3, 4]   (removes from original: arr -> [1,5])
split -> convert string → array
"a,b,c"
split(",")  -> ['a','b','c']

Q31: Event Bubbling vs Capturing
Bubbling: inner → outer (Event moves from child → parent)
<div onClick={()=>alert("Parent")}>
  <button onClick={()=>alert("Child")}>Click</button>
</div>

Capturing: outer → inner
addEventListener(type, fn, true) → capturing

Q32: What is Temporal Dead Zone (TDZ)?
Zone where variable exists but can’t be accessed before initialization.

Q33: Garbage Collection
JS automatically removes unused memory (unreferenced objects).
Explain the concept of prototype and prototypal inheritance.
Every JS object inherits from a prototype object.
Shared methods are defined on the prototype to save memory.
Example: Object.create(proto) creates a new object inheriting from proto.

Q34: Difference between call, apply, and bind.
call: fn.call(this, arg1, arg2) → calls immediately.
apply: fn.apply(this, [args]) → same but takes array.
bind: fn.bind(this) → returns new function for later call.

Q35: What are higher-order functions?
Functions that take another function as argument or return one (e.g., map, filter, reduce).

Q36: Explain the event loop and microtask queue.
JS is single-threaded; event loop manages async execution.
Microtasks: Promises.
Macrotasks: setTimeout, DOM events.
Microtasks run before next render cycle.

Q37: What are modules in JavaScript?
Break code into reusable files using export and import.
Types:
Named export
Default export
Example:
export const x = 1; 
import { x } from './file.js';

Q38:Use of Content-Type
Tells the browser what type of data is being sent.
Examples:
application/json → JSON data
text/html → HTML
multipart/form-data → File uploads

Q39: What is destructuring?
Extract values from arrays or objects easily:
const [a, b] = [1, 2];
const {name, age} = person;

Q40: What is a generator function?
A generator function can pause and resume execution using yield.
Defined with function* syntax.
Useful for lazy evaluation or async flows.
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}
const g = gen();
console.log(g.next().value); // 1
console.log(g.next().value); // 2
console.log(g.next().value); // 3


Q41: Explain the concept of immutability.
Data shouldn’t be modified directly; instead, create new copies.
Important for React state and predictable behavior.

Q42: All attributes of <script> tag
use script tag to include js in html
<script scr="index.js"></script>
src, type, async, defer, crossorigin

Q43: When to use defer / async
defer → loads JS in background, runs after HTML parsing, best for most scripts,Best for scripts that rely on the DOM.
async → runs as soon as loaded, may block DOM. Good for analytics.
HTML Parsing ──────► DOM Ready ──► Defer JS runs
        \
         \► Async JS runs whenever it finishes loading


Q44:Use of "use strict"
Makes JS more secure: prevents undeclared variables, silent errors.
"use strict"; x = 5;//error
but x = 5;//no error 

Q45:Data Types in JS (Primitive vs Non-Primitive)
Primitive: single value (immutable)(String, Number, boolean, null, undefined, symbol, bigint).
Non-Primitive:(mutable) Object, Array, function,Date,Math.

Q46:Null vs Undefined
null → empty value set by user.
undefined → declared but not assigned.

Q47: types of operator
Arithmetic:+,-,*,/,%,++,--
Assignment: =,+=,-=,*=,/=
Comparison:==,===,!=,!==,>,<,>=,<=
Logical: &&,||,!
Bitwise: 
Ternary:variable=(condition)?value1:value2

Q48:Parameter vs Argument
Parameter = variable in function definition.
Argument = actual value passed.
function add(a,b){ } add(2,3);

Q49:Callback Function
Function passed into another function to run after a task completes.
setTimeout(()=>console.log("done"),1000);

Q50:Pyramid of Doom (Callback Hell)
When many callbacks are nested inside each other — code becomes deep, messy, and hard to read.
getData(() => {
  processData(() => {
    saveData(() => {
      sendEmail(() => {
        console.log("Done");
      });
    });
  });
});

Q51:call back hell solved by Promise Chain
its readable and handle error easily
getData()
  .then(processData)
  .then(saveData)
  .then(sendEmail)
  .then(() => console.log("Done"))
  .catch(err => console.log("Error:", err));


Q52: Constructor
Used to create multiple similar objects.
function User(n){this.name=n;}
let u=new User("Sam");

Q53: Constructor Function
function User(name){this.name=name;}
let u=new User('Sam');

Q54: Strings are Immutable
Once created, can’t be changed—new copy made on edit.

Q55:new Array() vs []
new Array(3) creates empty slots, [] creates actual array.
Prefer [].
Example: const fruits=['Apple','Banana','Orange']
        const fruits=new Array('Apple','Banana','Orange')

Q56: create object without using new
const obj1 = {}; 
const obj2 = Object.create(null);
const obj3 = {name:"Sam"};
const obj4 = Object.assign({}, {a:1});
function makeObj(){return {id:1}}
const obj5 = makeObj();

Q57: Web APIs (browser features)
fetch(), setTimeout(), setInterval(), localStorage, sessionStorage,
document, navigator, geolocation, history, console, alert()

Q58: for of vs for in
1. for of does not work with object but for in works with Object and array
2. for of ignore extra properties which does not have index but for in does not ignore

Q59:map vs forEach
map returns new array; forEach just loops.

Q60: instanceof
Checks if object created from class.
obj instanceof MyClass;

Q61: Tree Shaking
Removes unused JS code during bundling.

Q62: what is DOM and its advantage
DOM: tree structure of HTML.
Advantage: JS can dynamically change HTML/CSS

Q63:Useful DOM Properties
.innerHTML, .textContent, .style, .classList, .value, .children, .parentElement

Q64:clientX vs scrollX
clientX → mouse position in viewport.
scrollX → amount page scrolled horizontally

Q65:Mouse Events
click, dblclick, mousedown, mouseup, mousemove, mouseenter, mouseleave

Q66:DOMContentLoaded
Fires when HTML fully parsed (before images).
Helps run JS early.

Q67: isNaN() and Number()
Checks if value is not number
isNaN('abc') → true

Q68:Cookies
Small data stored in browser; sent with every HTTP request.

Q69 Array Methods
push() → adds element to end. 
        [1,2].push(3) → [1,2,3]
pop() → removes element from end. 
        [1,2,3].pop() → [1,2]
unshift() → adds element to start. 
          [2,3].unshift(1) → [1,2,3]
shift() → removes element from start. 
        [1,2,3].shift() → [2,3]
concat() → joins two arrays.
        [1].concat([2,3]) → [1,2,3]
slice() → returns part of array. 
        [1,2,3,4].slice(1,3) → [2,3]
splice() → adds/removes elements at position.
         [1,2,3].splice(1,1,9) → [1,9,3]
indexOf() → finds first index of value. 
        [1,2,3].indexOf(2) → 1
includes() → checks if value exists.
        [1,2,3].includes(2) → true
join() → joins array elements into string.
         [1,2,3].join('-') → "1-2-3"
reverse() → reverses array order. 
        [1,2,3].reverse() → [3,2,1]
sort() → sorts array elements. 
        [3,1,2].sort() → [1,2,3]
map() → returns new array by applying function.
         [1,2].map(x=>x*2) → [2,4]
filter() → returns new array with matching elements.
        [1,2,3].filter(x=>x>1) → [2,3]
reduce() → combines all elements into single value.
       [1,2,3].reduce((a,b)=>a+b) → 6
forEach() → runs function for each element. 
      [1,2].forEach(x=>console.log(x))
find() → returns first matching element.
       [1,2,3].find(x=>x>1) → 2
findIndex() → returns index of first match.
      [1,2,3].findIndex(x=>x>1) → 1
every() → checks if all elements pass test.
      [2,4].every(x=>x%2===0) → true
some() → checks if any element passes test.
      [1,2].some(x=>x>1) → true
flat() → flattens nested arrays.
      [1,[2,3]].flat() → [1,2,3]
fill() → fills array with given value.
      [1,2,3].fill(0) → [0,0,0]
from() → creates array from iterable.
      Array.from('abc') → ['a','b','c']

Array CRUD
let a=[1,2,3];
a.push(4);  // add
a.splice(1,1); // remove
a[0]=9;     // update


Q70:String Methods
charAt() → returns character at index.
        "Hello".charAt(1) → "e"
charCodeAt() → returns ASCII of character.
        "A".charCodeAt(0) → 65
concat() → joins two strings.
        "Hello".concat(" World") → "Hello World"
includes() → checks if substring exists.
        "Hello".includes("lo") → true
indexOf() → finds first index of substring.
        "Hello".indexOf("l") → 2
lastIndexOf() → finds last index of substring.
        "Hello".lastIndexOf("l") → 3
slice() → extracts part of string.
        "Hello".slice(1,4) → "ell"
substring() → extracts part by index.
        "Hello".substring(1,4) → "ell"
replace() → replaces part of string.
        "Hello".replace("H","J") → "Jello"
split() → splits string into array.
        "a,b,c".split(",") → ["a","b","c"]
trim() → removes spaces from both ends.
        " hi ".trim() → "hi"
toUpperCase() → converts to uppercase.
        "hi".toUpperCase() → "HI"
toLowerCase() → converts to lowercase.
        "HI".toLowerCase() → "hi"
startsWith() → checks if string starts with given text.
        "Hello".startsWith("He") → true
endsWith() → checks if string ends with given text.
        "Hello".endsWith("lo") → true
repeat() → repeats string given times.
        "Hi".repeat(3) → "HiHiHi"

Q71:Object Methods
keys() → returns array of property names.
        Object.keys({a:1,b:2}) → ["a","b"]
values() → returns array of property values.
        Object.values({a:1,b:2}) → [1,2]
entries() → returns array of [key, value] pairs.
        Object.entries({a:1}) → [["a",1]]
assign() → copies values from one object to another.
        Object.assign({}, {a:1}) → {a:1}
hasOwnProperty() → checks if key exists in object.
        ({a:1}).hasOwnProperty("a") → true
delete → removes property from object.
        let obj={a:1}; delete obj.a → {}
freeze() → makes object immutable.
        Object.freeze({a:1}) can't change a
seal() → prevents adding or removing keys.
        Object.seal({a:1}) can't add/delete keys
create() → creates object with given prototype.
        Object.create(Array.prototype) → []
toString() → returns string form of object.
        ({a:1}).toString() → "[object Object]"

Q72: Pass by Value → Copy of value passed (primitive).
Pass by Reference → Reference (address) passed (object/array).

Q73: Pure Function → Same input → same output, no side effects.
Impure Function → Depends on external/state change.

Q74: Cross-Browser Scripting 
 Write JS that works same on all browsers (handle compatibility).

Q75: ES6 Features
 let/const, arrow fn, template literals, classes, modules, promises, destructuring
 ES5 Class Concept
 ES5 didn’t have class keyword — used constructor functions + prototypes
 function Person(name) {
  this.name = name;
}
Person.prototype.greet = function() {
  return "Hi " + this.name;
};

const p = new Person("Sam");
console.log(p.greet()); // Hi Sam

Q76:CORS 
 Cross-Origin Resource Sharing – allows API access from different domains.

Q77:Access DOM (4 ways)
getElementById()
getElementsByClassName()
querySelector()
querySelectorAll()

Q78:Event Emitter 
Object that listens (on) and triggers (emit) events.
const EventEmitter = require('events');
const event = new EventEmitter();
event.on('hi', ()=>console.log('Hello!'));
event.emit('hi');

Q79: Optimize DOM Traversal 
Cache DOM nodes, use documentFragment, batch updates

Q80: Webpack
Module bundler (combines JS, CSS, imgs into build).



====================
TYPESCRIPT THEORY NOTES
====================

Q1: What is TypeScript?
Superset of JS adding static typing + compiler checks.

Q2: why use it over JavaScript:
- Early error detection
- Better IntelliSense
- Type safety in large apps

Q3: Basic Types:
string, number, boolean, any, void, unknown, null, undefined

Q4: Interface Example:
interface User {
  name: string;
  age: number;
}

Q5: Type Alias:
type Status = "loading" | "success" | "error";

Q6: Optional and Readonly Properties:
interface User { name: string; age?: number; readonly id: number; }

Q7: Generics:
Generics allow you to write reusable functions or classes that can work with any data type while maintaining type safety.
function identity<T>(arg: T): T {
  return arg;
}
let str = identity<string>("Hello"); // type T is string
let num = identity<number>(42);      // type T is number

Q8: Union and Intersection Types:
Union (|) is a variable can hold one of multiple types
let val: string | number;
val = 5;     
val = "Hi";
Intersection (&) Combines multiple types into one. Variable/object must satisfy all types.
type A = { x: number };
type B = { y: string };
type C = A & B;
const obj: C = { x: 10, y: "hello" }; 

Q9: Enum:
Used to define named constants:
enum Color { Red, Green, Blue }
enum Direction { Up, Down, Left, Right }

Q10: Difference between Interface and Type
Interface -> extendable
Type -> can use union/intersection

Q11: Utility Types:
Partial<T>:Makes all properties of a type optional.
interface User {
  name: string;
  age: number;
}

const updateUser: Partial<User> = {
  name: "Alice" // age is optional now
};

Pick<T,K>:Selects a subset of properties from a type.
interface User {
  name: string;
  age: number;
  email: string;
}

const userContact: Pick<User, "name" | "email"> = {
  name: "Bob",
  email: "bob@example.com"
};

Omit<T,K>:Removes specified properties from a type.
interface User {
  name: string;
  age: number;
  password: string;
}

const publicUser: Omit<User, "password"> = {
  name: "Charlie",
  age: 25
};
Readonly<T>:Makes all properties of a type read-only
interface User {
  name: string;
  age: number;
}
const user: Readonly<User> = {
  name: "Dave",
  age: 30
};
user.age = 31;//error

Q12: Type Assertion:
let val: any = "hello";
let len = (val as string).length;

Q13: Difference between any and unknown and never
any -> unsafe
unknown -> needs type check before use

Q14: What are Decorators?
Experimental feature for class modification.
Special syntax to add metadata or modify classes/functions
Example:
@Logger
class User {}

Q15: Difference between TypeScript and JavaScript
TS -> compiled language
JS -> interpreted
TS adds types; JS doesn’t.

Q16: What is type narrowing?
Process of refining a variable’s type based on conditions.
Example:
if (typeof x === 'string') { x.toUpperCase(); }

Q17: What are type guards?
Functions or checks that help narrow down types at runtime.
Example:

function isString(x: unknown): x is string {
  return typeof x === 'string';
}