====================
JAVASCRIPT THEORY NOTES
====================

Q1: what is JavaScript? why name called JavaScript?
JavaScript is a lightweight, case sensitive scripting language.
JS was created to add logic to web pages;  initial name was "LiveScript" then marketing—syntax inspired by Java, but not related.

Q2: what are JavaScript engine?
a javascript engine is a computer programme that execute javascript code developed by web browser vender.
Example: chrome we have V8 firefox we have SpiderMonkey

Q1: What is Hoisting?
Variables and functions are moved to top of scope during compilation.
Example:
console.log(a); // undefined
var a = 5;

function foo(){
  console.log(a);//undefined
  var a =5;
}
foo()

Q2: What is Closure?
inner function remembers parent scope even after function ends.
Example:
function outer() {
  let count = 0;
  return function inner() {
    count++;
    console.log(count);
  }
}

Q3: Difference: var, let, const
var -> function scoped
let, const -> block scoped
const cannot be reassigned.

Q4: What is Event Loop?
Handles async operations. Executes sync code first, then callbacks from queue.
Example:
console.log('a');
setTimeout(()=>console.log('b'),0);
console.log('c');
// Output: a c b

Q5: What is 'this' keyword?
Refers to current context.
In function -> global/window
In object -> that object.

Q6: Arrow function vs normal function vs IIFE vs Anonymous function
Normal Function function add(a, b) { return a + b; }
Arrow Function  const add = (a, b) => a + b;
IIFE (Immediately Invoked Function Expression) (function(){ console.log("Run once"); })();
Anonymous Function let f=function(args){}

Q7: Shallow vs Deep Copy
Shallow: copies reference
Deep: copies values recursively.
Example:
let a = {x:1};
let b = {...a}; // shallow copy

Q8. What are Promises?
Used for async tasks.
Example:
new Promise((res, rej)=>res(5)).then(console.log);

Q9. Async/Await
Syntax sugar over Promises.
Example:
async function getData(){
  const data = await fetch(url);
}

Q10: What is Debounce & Throttle?
Debounce: delay execution till user stops typing.
Throttle: limit execution in interval.
Example:
function debounce(fn, delay){ let timer; return (...a)=>{clearTimeout(timer); timer=setTimeout(()=>fn(...a),delay);} }

Q11: Polyfill Example (map)
Array.prototype.myMap = function(cb){
  let res=[];
  for(let i=0;i<this.length;i++){
    res.push(cb(this[i],i));
  }
  return res;
}

Q12: Call, Apply, Bind
All used to set 'this' manually.
fn.call(obj, a,b);
fn.apply(obj, [a,b]);
fn.bind(obj)(a,b);

Q13: What is Currying?
Breaking function into multiple single-arg calls.
Example:
function add(a){return b=>a+b;}

Q14: What is Prototype?
JS uses prototypal inheritance. Every object has a hidden [[Prototype]].
Objects inherit from __proto__ → links to [[Prototype]]

Q15: Difference: undefined vs null
undefined -> declared but not assigned
null -> intentional empty value.

Q16: Event Delegation
Attach single listener to parent.
Example:
ul.addEventListener('click',(e)=>{ if(e.target.tagName==='LI') console.log(e.target.textContent) })

Q17: LocalStorage vs SessionStorage
localStorage -> persists after reload
sessionStorage -> clears when tab closes

Q18: Spread vs Rest
Spread -> expands [...arr]
Rest -> collects (...args)

Q19: Deep Clone Object
JSON.parse(JSON.stringify(obj));

Q20: Optional Chaining
Access nested property safely: user?.address?.city

Q21: Difference Between == and ===
== does type coercion
=== checks type + value

Q22: Difference Between slice, splice, split
slice -> copy array portion
splice -> modify array
split -> convert string → array

Q23: Event Bubbling vs Capturing
Bubbling: inner → outer
Capturing: outer → inner
addEventListener(type, fn, true) → capturing

Q24: What is Temporal Dead Zone (TDZ)?
Zone where variable exists but can’t be accessed before initialization.

Q25: Garbage Collection
JS automatically removes unused memory (unreferenced objects).
Explain the concept of prototype and prototypal inheritance.
Every JS object inherits from a prototype object.
Shared methods are defined on the prototype to save memory.
Example: Object.create(proto) creates a new object inheriting from proto.

Q26: Difference between call, apply, and bind.
call: fn.call(this, arg1, arg2) → calls immediately.
apply: fn.apply(this, [args]) → same but takes array.
bind: fn.bind(this) → returns new function for later call.

Q27: What are higher-order functions?
Functions that take another function as argument or return one (e.g., map, filter, reduce).

Q28: Explain the event loop and microtask queue.
JS is single-threaded; event loop manages async execution.
Microtasks: Promises.
Macrotasks: setTimeout, DOM events.
Microtasks run before next render cycle.

Q29: What are modules in JavaScript?
Break code into reusable files using export and import.
Example:
export const x = 1; 
import { x } from './file.js';


Q30: Difference between shallow and deep copy.

Shallow copy: copies only top-level properties (e.g., spread operator).
Deep copy: copies all nested objects (e.g., structuredClone, recursion).

Q31: What is destructuring?
Extract values from arrays or objects easily:
const [a, b] = [1, 2];
const {name, age} = person;


Q32: What is a generator function?
Function that can pause/resume with yield.
Defined with function*.
Used for lazy evaluation or async flows.

Q33: Explain the concept of immutability.
Data shouldn’t be modified directly; instead, create new copies.
Important for React state and predictable behavior.

Q34: All attributes of <script> tag
use script tag to include js in html
<script scr="index.js"></script>
src, type, async, defer, crossorigin

Q35: When to use defer / async
defer → loads JS in background, runs after HTML parsing, best for most scripts.
async → runs as soon as loaded, may block DOM. Good for analytics.

Q36:Use of "use strict"
Makes JS more secure: prevents undeclared variables, silent errors.
"use strict"; x = 5;//error
but x = 5;//no error

Q37:Primitive vs Non-Primitive
Primitive: single value (immutable)(String, Number, boolean, null, undefined, symbol, bigint).
Non-Primitive:(mutable) Object, Array, function,Date,Math.

Q38:Null vs Undefined
null → empty value set by user.
undefined → declared but not assigned.

Q39: types of operator
Arithmetic:+,-,*,/,%,++,--
Assignment: =,+=,-=,*=,/=
Comparison:==,===,!=,!==,>,<,>=,<=
Logical: &&,||,!
Bitwise: 
Ternary:variable=(condition)?value1:value2

Q40:Parameter vs Argument
Parameter = variable in function definition.
Argument = actual value passed.
function add(a,b){ } add(2,3);

Q41:Callback Function
Function passed into another function to run after a task completes.
setTimeout(()=>console.log("done"),1000);

Q42:Pyramid of Doom (Callback Hell)
When many callbacks are nested inside each other — code becomes deep, messy, and hard to read.
getData(() => {
  processData(() => {
    saveData(() => {
      sendEmail(() => {
        console.log("Done");
      });
    });
  });
});
Q48:call back hell solved by Promise Chain
its readable and handle error easily
getData()
  .then(processData)
  .then(saveData)
  .then(sendEmail)
  .then(() => console.log("Done"))
  .catch(err => console.log("Error:", err));


Q42: Constructor
Used to create multiple similar objects.
function User(n){this.name=n;}
let u=new User("Sam");

Q43: Strings are Immutable
Once created, can’t be changed—new copy made on edit.

Q44:new Array() vs []
new Array(3) creates empty slots, [] creates actual array.
Prefer [].
Example: const fruits=['Apple','Banana','Orange']
        const fruits=new Array('Apple','Banana','Orange')

Q45: for of vs for in

1. for of does not work with object but for in works with Object and array
2. for of ignore extra properties which does not have index but for in does not ignore

Q46:map vs forEach
map returns new array; forEach just loops.

Q47: instanceof
Checks if object created from class.
obj instanceof MyClass;



Q49: Tree Shaking
Removes unused JS code during bundling.

Q50:Useful DOM Properties
.innerHTML, .textContent, .style, .classList, .value, .children, .parentElement

Q51:clientX vs scrollX

clientX → mouse position in viewport.
scrollX → amount page scrolled horizontally

Q52:Mouse Events
click, dblclick, mousedown, mouseup, mousemove, mouseenter, mouseleave

Q53:DOMContentLoaded
Fires when HTML fully parsed (before images).
Helps run JS early.

Q54:localStorage vs sessionStorage

localStorage: permanent until cleared.
sessionStorage: cleared on tab close.

Q55:Cookies
Small data stored in browser; sent with every HTTP request.

Q56 Array Methods
push() → adds element to end.
pop() → removes element from end.
unshift() → adds element to start.
shift() → removes element from start.
concat() → joins two arrays.
slice() → returns part of array.
splice() → adds/removes elements at position.
indexOf() → finds first index of value.
includes() → checks if value exists.
join() → joins array elements into string.
reverse() → reverses array order.
sort() → sorts array elements.
map() → returns new array by applying function.
filter() → returns new array with matching elements.
reduce() → combines all elements into single value.
forEach() → runs function for each element.
find() → returns first matching element.
findIndex() → returns index of first match.
every() → checks if all elements pass test.
some() → checks if any element passes test.
flat() → flattens nested arrays.
fill() → fills array with given value.
from() → creates array from iterable.

Q57:String Methods
charAt() → returns character at index.
charCodeAt() → returns ASCII of character.
concat() → joins two strings.
includes() → checks if substring exists.
indexOf() → finds first index of substring.
lastIndexOf() → finds last index of substring.
slice() → extracts part of string.
substring() → extracts part by index.
replace() → replaces part of string.
split() → splits string into array.
trim() → removes spaces from both ends.
toUpperCase() → converts to uppercase.
toLowerCase() → converts to lowercase.
startsWith() → checks if string starts with given text.
endsWith() → checks if string ends with given text.
repeat() → repeats string given times.

Q58:Object Methods
keys() → returns array of property names.
values() → returns array of property values.
entries() → returns array of [key, value] pairs.
assign() → copies values from one object to another.
hasOwnProperty() → checks if key exists in object.
delete → removes property from object.
freeze() → makes object immutable.
seal() → prevents adding or removing keys.
create() → creates object with given prototype.
toString() → returns string form of object.


====================
TYPESCRIPT THEORY NOTES
====================

1️⃣ What is TypeScript?
Superset of JS adding static typing + compiler checks.

2️⃣ why use it over JavaScript:
- Early error detection
- Better IntelliSense
- Type safety in large apps

3️⃣ Basic Types:
string, number, boolean, any, void, unknown, null, undefined

4️⃣ Interface Example:
interface User {
  name: string;
  age: number;
}

5️⃣ Type Alias:
type Status = "loading" | "success" | "error";

6️⃣ Optional and Readonly Properties:
interface User { name: string; age?: number; readonly id: number; }

7️⃣ Generics:
function identity<T>(arg: T): T { return arg; }

8️⃣ Union and Intersection Types:
let val: string | number;
type A = {x:number}; type B = {y:string};
type C = A & B;

9️⃣ Enum:
Used to define named constants:
enum Color { Red, Green, Blue }
enum Direction { Up, Down, Left, Right }


10️⃣ Difference between Interface and Type
Interface -> extendable
Type -> can use union/intersection

11️⃣ Utility Types:
Partial<T>, Pick<T,K>, Omit<T,K>, Readonly<T>

12️⃣ Type Assertion:
let val: any = "hello";
let len = (val as string).length;

13️⃣ Difference between any and unknown and never
any -> unsafe
unknown -> needs type check before use

14️⃣ What are Decorators?
Experimental feature for class modification.
Special syntax to add metadata or modify classes/functions
Example:
@Logger
class User {}

15️⃣ Difference between TypeScript and JavaScript
TS -> compiled language
JS -> interpreted
TS adds types; JS doesn’t.

. What is type narrowing?
Process of refining a variable’s type based on conditions.
Example:

if (typeof x === 'string') { x.toUpperCase(); }


2. What are type guards?
Functions or checks that help narrow down types at runtime.
Example:

function isString(x: unknown): x is string {
  return typeof x === 'string';
}