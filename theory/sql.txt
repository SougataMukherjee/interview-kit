====================
SQL BASICS
====================
Q1: What is SQL?what is Schema?
A: Structured Query Language used to store, retrieve, and manipulate data in relational databases.
    Structure of database (tables, views, relations).
Q2: Difference between SQL and NoSQL?
A: SQL → structured tables with schema.
   NoSQL → flexible schema (JSON, documents, key-value).

Execution Order
FROM → WHERE → GROUP BY → HAVING → SELECT → DISTINCT → ORDER BY → LIMIT/TOP

Q3: Types of SQL Commands:
A:
DDL (Data Definition Language): CREATE, ALTER, DROP, TRUNCATE
DML (Data Manipulation Language): SELECT, INSERT, UPDATE, DELETE
DCL (Data Control Language): GRANT, REVOKE
TCL (Transaction Control Language): COMMIT, ROLLBACK, SAVEPOINT
DQL (Data Query Language): SELECT


Note:DELETE vs DROP vs TRUNCATE
DELETE → removes rows and keeps table (can rollback)
TRUNCATE → removes all rows (no rollback)
DROP → removes entire table

Note:WHERE vs HAVING
WHERE → before grouping
HAVING → after grouping

====================
QUERY BASICS
====================
Q4: Get all records from Employee table
A: SELECT * FROM Employee;

Q5: Get employees whose salary > 50000
A: SELECT name, salary FROM Employee WHERE salary > 50000;

Q6: Sort employees by name
A: SELECT * FROM Employee ORDER BY name ASC;

====================
JOINS
====================
Q7: Inner Join example
A:
SELECT e.name, d.dept_name
FROM Employee e
INNER JOIN Department d
ON e.dept_id = d.id;

Q8: Difference between LEFT JOIN and INNER JOIN
A:
INNER JOIN → common records only
LEFT JOIN → all from left + matched from right

====================
AGGREGATE & GROUPING
====================
Q9: Find total employees per department
A:
SELECT dept_id, COUNT(*) as total
FROM Employee
GROUP BY dept_id;

Q10: Filter grouped results with HAVING
A:
SELECT dept_id, COUNT(*) as total
FROM Employee
GROUP BY dept_id
HAVING COUNT(*) > 5;

====================
ADVANCED
====================
Q11: Find 2nd highest salary
A:
SELECT MAX(salary) FROM Employee
WHERE salary < (SELECT MAX(salary) FROM Employee);

Q12: What is a CTE (WITH clause)?
A:
Temporary result used in next SELECT.
Example:
WITH HighSalary AS (
  SELECT * FROM Employee WHERE salary > 50000
)
SELECT * FROM HighSalary WHERE dept_id=3;

Q13: What is indexing?
A: Data structure to speed up SELECT queries by avoiding full table scans.
Speeds up search using pointers

Q14: Explain ACID properties
A:
Atomicity - All or nothing
Consistency - Maintains valid state
Isolation - Transactions don’t interfere
Durability - Changes are permanent

Q15: DB vs DBMS 
DB = data storage;
DBMS = software to manage it (e.g., MySQL, PostgreSQL)

Q16: Schema / Table
Schema = blueprint;
Table = actual data.

Q17:SET vs JOIN
SET → combines results vertically (UNION, INTERSECT)
JOIN → combines horizontally (based on keys)

Q18:UNION ALL vs UNION 
UNION ALL → includes duplicates
UNION → removes duplicates

Q19:Aggregate vs Window Function
Aggregate → summarizes (SUM, AVG)
Window → works per row with context (RANK, ROW_NUMBER)

Q20:Stored Procedure 
Predefined SQL block stored in DB for reuse



========================
SQL NOTES
========================
large object
a)clob(character large object) this is used to store the character upto 4 gb of size where in varchar max store 4000
b)blob(binary large object)this is used to store binary number of images,videosfile upto 4gb size

constraints constraints are the conditions that are assigned to a particular column to validate the data
types:1)UNIQUE is a constraint which is assigned to a particular column which can not accept duplicate value
2) NOt Null notnull is a constraint which is assigned to a particular column which can not be null or which are mandatory
 3)CHECK is a constraints which is assigned to a particular column for extra validation
 4)Primary key is a constraints which is used to assign a column to identify a record uniquely from the table E:g aadhar card 
we can have only one primary key in a table and it can not accept null or duplicate values and its not mandatory but recomended to use
5)Foreign key is a constraints which is used to establish the connection between two tables
we can have n number of foreign key in a table and it can accept repeated duplicate value even null and it also reffer as referential intigrity constraints
Composite key – Combination of 2+ columns as primary key.

Expression a statements which gives us result is known as expression
Expression concept of two types operand and operators(+,-,*,/)

Alias alias is an alternative name given to a column or expression in a result table
alias name can be used with or without using AS keyword and its not a mandatory

select * [DISTINCT] column_name/Expression[Alies]

Distinct to remove repeated value or duplicate value in result table we use distinct clause
for distinct clause we can pass column name or expression
we can pass multiple column for distinct clause

Where clause this is used to filter the record
SELECT * FROM Customers WHERE Country = 'India';


AND and OR operator: 
AND operator return true if both condition true
OR operator return true if any one condition true

BETWEEN and NOT BETWEEN operator:
between operator is used whenever we have range
not between is simillar to between operator but it reject the value instead of selecting it
syntax

IS and IS NOT operator
IS operator is used only to compare with null
Is Not is similar of is but it reject the value instead of selecting

LiKE operator
LIke operator is used whenever we need to match the pattern
percentile(%) it can accept any character any number of times
underscore(_) it can accept any character but only once
first character must A - A%
Last character must A - %A
Second Character must A- _A%
Second last character must A - %A_


Subqueries
A query inside another query.
Single Row Subquery → Returns exactly one value.
Example operators: =, >, <, >=, <=
Multi Row Subquery → Returns multiple values.
Example operators: IN, NOT IN, ANY, ALL

Any operator
any operator is a special operator which can accept multiple value at rhs,it will return true if anyone of the condition at the rhs is satisfied


Joins: this statements is used to retrieve the data from multiple table simultaneously
types of join
1)cartesian join or cross join
here a record from a table 1 will be marged with all the record of table 2
number of columns in result table will be summation of column present in table 1 table 2

2)inner join or equi join
we use inner join to obtain only the matched records or the records which as pair

3)outer join
in outer join we get the unmatch record along with the match record
	Left outer join
	Right outer join
	FULL OUTER JOIN
4)self join
self join is used to join the same two tables ot the table itself

5)natural join
Automatically joins tables based on columns with the same name

SQL Functions
MOD(x, y) → Returns remainder of division (x % y).
Example: MOD(10, 4) → 2
NVL(expr1, expr2) → Returns expr2 if expr1 is NULL.
Example: NVL(salary, 0)
INSTR(string, substring) → Returns position of substring inside string.
INSTR() this function is used to obtain inside value of the substring which is present in the original string 
Note:NVL vs NVL2
NVL(expr1, expr2) → if null, replace with expr2
NVL2(expr1, expr2, expr3) → if not null expr2 else expr3

pseudo columns:
pseudo columns are the false columns that are present in each and every table and must be called explicitly
types of pseudo columns
RowId: rowid is 8 digit address in which the record is present in the record is store in the memory
RowNum: Rownum acts as serial number to the result table 
both are unique, it cannot be duplicate

Product never ordered
SELECT * FROM Product 
WHERE product_id NOT IN (SELECT product_id FROM Orders);

DBMS vs RDBMS 
RDBMS uses tables + relations (foreign keys).

Normalization – Reduces redundancy; organizes data.
  Normalization forms –
1NF – atomic columns
2NF – no partial dep
3NF – no transitive dep
Views – Virtual table based on query.

Trigger – Auto executes on INSERT/UPDATE/DELETE.
Cursor – Row-by-row pointer to query result.

Stored procedure – Precompiled SQL block for reuse.
Temporary table – Exists for session only
EXISTS vs IN –
EXISTS → checks row existence (faster)
IN → compares values list
CHAR vs VARCHAR
CHAR → fixed length
VARCHAR → variable length

SQL vs NoSQL
SQL → structured tables
NoSQL → unstructured (JSON, key-value, doc)
=========================
CREATE TABLE Customers (
  CustomerID INT PRIMARY KEY,
  CustomerName VARCHAR(100) UNIQUE NOT NULL,
  ContactName VARCHAR(100),
  Address VARCHAR(150),
  City VARCHAR(50),
  PostalCode VARCHAR(10),
  Country VARCHAR(50)
);

CREATE TABLE Products (
  ProductID INT PRIMARY KEY,
  ProductName VARCHAR(100),
  Price DECIMAL(10,2)
);

CREATE TABLE OrderDetails (
  OrderID INT,
  ProductID INT,
  Quantity INT
);

INSERT INTO Customers (CustomerID, CustomerName, ContactName, Address, City, PostalCode, Country) VALUES
(1, 'Sam', 'Boss1', 'BK street', '12209', 'Germany'),
(2, 'Mike', 'Boss2', 'Green Garden', 'México D.F.', '05021', 'Mexico'),
(3, 'Jake', 'Boss3', 'MK houl', 'Madrid', '28023', 'Spain'),
(4, 'Rupai', 'Boss4', '5 sq road', 'London', 'WA1 1DP', 'UK'),
(5, 'Rik', 'Boss5', 'BK colony', 'Mannheim', '68163', 'Germany'),
(6, 'Sou', NULL, 'Lord Bunglo', 'Milan', '20100', 'Italy');

INSERT INTO Products (ProductID, ProductName, Price) VALUES
(1, 'Chais', 18.00),
(2, 'Chang', 19.00),
(3, 'Aniseed Syrup', 10.00),
(4, 'Chef Anton''s Cajun Seasoning', 22.00),
(5, 'Chef Anton''s Gumbo Mix', 21.35);

INSERT INTO OrderDetails (OrderID, ProductID, Quantity) VALUES
(101, 1, 10),
(102, 2, 20),
(103, 3, 15),
(104, 4, 25);


SELECT * FROM Customers;
-- Shows all rows and columns from Customers table
-- +-------------+---------------+-------------+-------------+----------+-------------+----------+
-- | CustomerID  | CustomerName  | ContactName | Address     | City     | PostalCode  | Country  |
-- +-------------+---------------+-------------+-------------+----------+-------------+----------+
-- | 1 | Sam   | Boss1 | BK street    | 12209     | Germany   |
-- | 2 | Mike  | Boss2 | Green Garden | México D.F.| Mexico   |
-- | 3 | Jake  | Boss3 | MK houl      | Madrid    | Spain     |
-- | 4 | Rupai | Boss4 | 5 sq road    | London    | UK        |
-- | 5 | Rik   | Boss5 | BK colony    | Mannheim  | Germany   |
-- | 6 | Sou   | NULL  | Lord Bunglo  | Milan     | Italy     |

SELECT CustomerName, City FROM Customers;
-- Displays only specific columns
-- +--------------+------------+
-- | CustomerName | City       |
-- +--------------+------------+
-- | Sam          | 12209      |
-- | Mike         | México D.F.|
-- | Jake         | Madrid     |
-- | Rupai        | London     |
-- | Rik          | Mannheim   |
-- | Sou          | Milan      |


SELECT DISTINCT Country FROM Customers;
-- Removes duplicate country names
-- +----------+
-- | Country  |
-- +----------+
-- | Germany  |
-- | Mexico   |
-- | Spain    |
-- | UK       |
-- | Italy    |


SELECT * FROM Customers WHERE Country='Mexico';
-- Filters customers only from Mexico
-- +-------------+----------+----------+--------------+-------------+----------+
-- | CustomerID  | Name     | Contact  | Address      | City        | Country  |
-- +-------------+----------+----------+--------------+-------------+----------+
-- | 2 | Mike | Boss2 | Green Garden | México D.F. | Mexico |


SELECT * FROM Products ORDER BY Price;
-- Sorts products in ascending order of price
-- +-----------+----------------------------+--------+
-- | ProductID | ProductName                | Price  |
-- +-----------+----------------------------+--------+
-- | 3 | Aniseed Syrup              | 10.00 |
-- | 1 | Chais                      | 18.00 |
-- | 2 | Chang                      | 19.00 |
-- | 5 | Chef Anton's Gumbo Mix     | 21.35 |
-- | 4 | Chef Anton's Cajun Seasoning| 22.00 |


SELECT * FROM Customers WHERE Country='Germany' OR Country='Spain';
-- Shows customers either from Germany or Spain


SELECT * FROM Customers WHERE NOT Country='Spain';
-- Shows customers not from Spain

SELECT TOP 3 * FROM Customers;  -- For MySQL use: SELECT * FROM Customers LIMIT 3;
-- Shows only first 3 rows

SELECT MIN(Price) FROM Products;
-- Shows smallest price value
-- +------------+
-- | MIN(Price) |
-- +------------+
-- | 10.00      |

SELECT COUNT(*) FROM Products;
-- Counts total number of rows
-- +----------+
-- | COUNT(*) |
-- +----------+
-- | 5        |

SELECT SUM(Quantity) FROM OrderDetails;
-- Adds up all quantities
-- +---------------+
-- | SUM(Quantity) |
-- +---------------+
-- | 70            |


SELECT AVG(Price) FROM Products;
-- Finds average price
-- +------------+
-- | AVG(Price) |
-- +------------+
-- | 18.47      |

SELECT * FROM Customers WHERE CustomerName LIKE 'a%';
-- Finds customer names starting with 'a'
-- (No result since none starts with 'a')


SELECT * FROM Customers WHERE Country IN ('Germany', 'France', 'UK');
-- Shows only rows where Country matches any in the list

SELECT * FROM Products WHERE Price BETWEEN 10 AND 20;
-- Filters rows where price lies between 10 and 20

SELECT CustomerID AS ID FROM Customers;
-- Renames column CustomerID to ID in output
-- +----+
-- | ID |
-- +----+
-- | 1  |
-- | 2  |
-- | 3  |
-- | 4  |
-- | 5  |
-- | 6  |

SELECT ProductName, AVG(Price) AS price
FROM Products
GROUP BY ProductName;

SELECT * FROM Customers WHERE LOWER(CustomerName) = 'sam';//search for customer name 'Sam'

SELECT * FROM Customers
WHERE CustomerName LIKE 'R%' OR CustomerName LIKE 'S%';//customer name starts with R or S

