==============================
REACT THEORY NOTES 
==============================

Q1: What is Virtual DOM?How React Manages Virtual DOM?
 A lightweight JS representation of the real DOM. React updates only changed nodes, improving performance.
React keeps a virtual copy of the DOM → compares (diff) → updates only changed parts.

Q2: What is Reconciliation?
 The diffing process where React compares old and new virtual DOM trees and updates only changed parts.

How diffing algorithm works in Virtual DOM
 React compares old and new virtual DOM trees, updates only changed nodes (O(n) optimization).

Q3: Functional vs Class Components
 Functional - simpler, uses hooks.
 Class - uses lifecycle methods, more boilerplate.

Q4: What are Hooks in React?
 Functions that let you use React features without classes (e.g. useState, useEffect, useMemo, useCallback).

Q5: Explain useState
 Manages local state in functional components.
Example:
const [count, setCount] = useState(0);

Q6: Explain useEffect
 Performs side effects after render.(API calls, event, etc)
Example:
useEffect(() => { console.log('runs after render'); }, []);

Q6: Lifecycle using useEffect
useEffect(()=>{console.log("Mount")},[]); // Mount
useEffect(()=>{console.log("Update")},[val]); // Update
useEffect(()=>()=>console.log("Unmount"),[]); // Unmount

Q7: useMemo vs useCallback
useMemo → memoizes computed value
const [count, setCount] = useState(0);
  const double = useMemo(() => {
    console.log("Calculating...");
    return count * 2;
  }, [count]);
useCallback → memoizes/caches function reference
const [count, setCount] = useState(0);
  const handleClick = useCallback(() => {
    setCount(c => c + 1);
  }, []);


Q8: What is Prop Drilling?
 Passing props deeply through multiple components. Solved using Context API.

Q9: What is Context API?
 Provides global state without prop drilling and solution for props drilling.
Example:
const UserContext = createContext();

Q10: What is React.memo?
 Prevents unnecessary re-renders of functional components when props don’t change.

Q11: Controlled vs Uncontrolled Components
Controlled - state managed by React.
Uncontrolled - managed by DOM via refs.

Q12: What is useRef?
 Used to access DOM elements or persist mutable values without re-render.
Example:
const inputRef = useRef();
-When do you need to use refs?
To directly access DOM elements or React elements.
Use case: focus input, play video, integrate 3rd-party lib.

Q13: Explain React Fiber
 Internal engine for scheduling rendering tasks efficiently.

Q14: Difference between keys in React list
 Unique key helps React identify elements and track updates efficiently.

Q15: Lifecycle methods in class component
Mounting → componentDidMount
Updating → componentDidUpdate
Unmounting → componentWillUnmount

componentDidMount vs useEffect
componentDidMount (class) = runs once after mount.
componentDidMount() → Used only once in a class component; runs after the component is mounted.
useEffect(()=>{},[]) (hook) = same behavior in functional components.
useEffect() → Used in functional components; you can have multiple useEffect hooks for different side effects, and control when they run using dependency arrays

Q16: What is HOC (Higher Order Component)?
 A function that takes a component and returns a new component with added functionality.

Q17: What is React Fragment?
<></> wrapper to avoid adding extra DOM nodes.

Q18: Error boundaries and limitation
Components that catch JS errors in child tree and display fallback UI.
but Error Boundaries cannot catch:
     Errors inside event handlers.
     Errors in asynchronous code(like setTimeout,fetch)

Q19. how to handle error in react?
class ErrorBoundary extends React.Component {
  state = { hasError: false };
  componentDidCatch() { this.setState({ hasError: true }); }
  render() {
    return this.state.hasError ? <h3>Something went wrong</h3> : this.props.children;
  }
}
and use like <ErrorBoundary><MyComponent/></ErrorBoundary>


Q19: Difference between state and props
State - internal, mutable.
Props - external, immutable.

Q20: How does React handle events?
Through synthetic events, which wrap native events for cross-browser compatibility.
Virtual DOM → In-memory copy of real DOM for faster UI diff & updates.
SPA (Single Page App) → One HTML loaded once; updates view via JS routing.
Babel → JS compiler that converts modern JS/JSX → browser-compatible code.
HOC (Higher-Order Component) → Function that takes a component and returns a new one with extra features.

Code-split / Lazy-load → Load parts of app only when needed for better performance
import("./math").then(math => {
  console.log(math.add(16, 20)); 
});

Q21. Route & Protected Route
Route: Defines which component to show for a path.
Protected Route: Restricts access (e.g. only logged-in users).

Q22. Render Props
Share logic by passing a function as a prop that returns JSX.
<Data render={(data) => <List data={data}/>}/>

Q23.React.createElement vs React.cloneElement
createElement: Creates a new element.
function Greeting({ name }) {
  return React.createElement(
    'h1',
    { className: 'greeting' },
    'Hello'
  );
}
cloneElement: Copies an element and adds new props/children.

Q24. Event-driven Architecture
Code reacts to events (e.g., click, message).
Microfrontend Architecture
Break big app into small independent frontends.

Q25.Types of API Calls
GET (read), POST (create), PUT/PATCH (update), DELETE (remove).

Q26.Type Checking with PropTypes
import PropTypes from 'prop-types';
Comp.propTypes = { name: PropTypes.string.isRequired };

Q27. React 18 Features
  1.Automatic Batching:Combines multiple state updates into one render.
  fetch('/api').then(()=>{
 setA(1); setB(2); setC(3); // only 1 re-render
});
  2.Transitions:Used for non-urgent updates
  import { startTransition } from 'react';
startTransition(() => setPage('home'));

Q28: Render Props
Share logic between components using function prop
<Data render={data => <List data={data}/>}/>

Q29: Axios
axios.get('/users');
axios.post('/users',{name:'Sam'});
axios.put('/user/1',{name:'A'});
axios.delete('/user/1');

Q30: Library vs Framework
Library: you control flow (React)
Framework: it controls flow (Angular)

Q31: React vs React DOM
React → core logic
ReactDOM → renders UI in browser

Q32: JSX
JS + HTML
const el = <h1>Hello {name}</h1>;

Q33:How do you print falsy values in JSX?
 Wrap in {String(value)} or conditional render.{String(false)}  // prints "false"

Q34.Is it possible to use React without JSX?
 Yes.
 React.createElement('h1', null, 'Hello');

Q35:How JSX prevents Injection Attacks?
 JSX escapes values before rendering → prevents XSS.
 <div>{userInput}</div> // safe

Q36: Props vs State
Props: read-only
State: mutable (internal data)

Q37: types of conditional rendering
isLogged ? <Home/> : <Login/>
status && <Loader/>
msg || "No message"

Q38: Folder Structure
React: src/components, hooks, pages, utils
Next.js: app/, pages/, components/, public/

Q39: Purpose of forwardRef?
Pass ref from parent → child component.
const Input = React.forwardRef((props, ref) => <input ref={ref} />);

Q40. What is Suspense component?
 Used to show fallback UI while loading async content (like lazy components).
<Suspense fallback={<p>Loading...</p>}> <MyComp /> </Suspense>

Q41. How to prevent component from rendering?
Return null inside render.
if(!isVisible) return null;

Q42. What are portals in React?
Render children outside parent DOM hierarchy.
ReactDOM.createPortal(child, domNode);

Q43. Why not call setState in componentWillUnmount()?
Component already unmounted → causes memory leak warning.

Q44. Is constructor mandatory in React class component?
No. Only needed when using this.state or binding methods.

Q45. How do you pass arguments to event handler?
 Use arrow function.
 onClick={() => handleClick(id)}




==============================
NEXT.JS THEORY NOTES 
==============================

Q1: What is Next.js?
 A React framework for server-side rendering, static site generation, and optimized performance.

Q2: CSR vs SSR vs SSG
CSR - Rendered on client (useEffect),its render in browser for fast navigation
SSR - Rendered on server per request (getServerSideProps),Render on server before sending HTML (better SEO)
SSG - Pre-built HTML at build time (getStaticProps)

Q3: Explain getStaticProps
Used for static generation; runs at build time only and provides props to page and Generates static HTML.
we use when Data changes rarely
export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/users');
  const users = await res.json();
  return {
    props: { users }, // passed to the component
  };
}

export default function Users({ users }) {
  return (
    <div>
      <h2>User List</h2>
      {users.map(u => (
        <p key={u.id}>{u.name}</p>
      ))}
    </div>
  );
}

Q4: Explain getServerSideProps
Runs on each request; fetches data on server before rendering.Data fetched fresh each time.
export default async function Page() {
  const res = await fetch("https://api.example.com/data", { cache: "no-store" });
  const data = await res.json();
  return <pre>{JSON.stringify(data, null, 2)}</pre>;
}

Q5: Explain getStaticPaths
Used with dynamic routes to pre-render specific paths at build time.

Q6: Difference between pages and app router
- Pages router: uses /pages directory, older version.
- App router: introduced in Next.js 13, uses /app directory, server components, and layout.js.

Q7: What are Server Components?
Components rendered on the server — faster, smaller bundles, no client JS needed.

Q8: What are Client Components?
Components rendered in the browser using "use client" directive.

Q9: How to create API routes in Next.js?
Create serverless functions inside /pages/api or /app/api folder each file becomes an API endpoint.
Example:
export default function handler(req, res) { res.json({ msg: 'Hello' }) }

Q10: Difference between next/link and a tag
 next/link does client-side routing (faster, no reload), <a> tag reloads the page.

Q11: What is Image Optimization in Next.js?
 <Image /> automatically optimizes image size and format for performance.
 it Resizes large images to the size needed by the device,Lazy-loads images,Serves responsive images with srcset
 import Image from "next/image";
 <Image
        src="/images/profile.jpg"
        alt="Profile"
        width={300}
        height={300}
        quality={80}
        priority
      />

Q12: What is Middleware in Next.js?
 Runs before request is completed, used for auth, redirects, or rewrites.

Q13: How to handle environment variables in Next.js?
 Stored in .env.local and accessed via process.env.NAME

Q14: What is ISR (Incremental Static Regeneration)?
 Allows static pages to update at runtime after a set interval (revalidate).

Q15: What is next/head used for?
 To modify <head> tags dynamically (title, meta tags).it improve SEO and Custom scripts like Google Analytics
 import Head from "next/head";
<Head>
    <title>My Portfolio</title>
    <meta name="description" content="Frontend Developer in Bangalore" />
    <meta property="og:title" content="Portfolio Site" />
</Head>

Q16: What is next/script?
 Used to control script loading strategy (lazyOnload, beforeInteractive, etc.).it will load script only when needed to improve performance.
<Script
        src="https://www.googletagmanager.com/gtag/js?id=GA_TRACKING_ID"
        strategy="afterInteractive"
      />

Q17: How to handle API fetching in Next.js 13 app router?
 Use async server components with fetch directly inside component.

Q18: What is Dynamic Routing in Next.js?
 File-based routing with parameters using [id].js files.
// pages/users/[id].js
import { useRouter } from "next/router";

export default function User() {
  const router = useRouter();
  const { id } = router.query; // get dynamic value from URL
  return <h1>User ID: {id}</h1>;
}

Q19: What are Layouts and Templates in Next.js 13?
Layouts persist between routes; templates re-render on navigation.
Layouts = Common UI (like Navbar/Footer).
Templates = Predefined page structures reused across routes.
export default function HomeLayout({ children }) {
  return (
    <div className="structure">
      <Header />
      <main>{children}</main>
      <Footer />
    </div>
  );
}

Q20: all route and folder Next.js app?
dynamic route [segment] → For routes like /user/[id], dynamic by parameter.
optional catch-all [...segment] → Matches /a, /a/b, /a/b/c.
optional [ [ ...segment ] ] → Same but optional (works with or without param).
private folder (folder) → Grouping folder not part of route path.
underscore _folder → Conventionally means internal folder (ignored by Next).

Q21: Styled JSX in Next.js
Built-in CSS-in-JS for component-level styling using <style jsx> tag.

Q22: How to improve SEO
Use SSR/SSG, meta tags, sitemap, semantic HTML, image alt, clean URLs.

Q23: Optimized data fetching (getStaticProps)
Yes getStaticProps pre-renders pages at build time for faster load.

Q24: Types of styling in Next.js
CSS Modules, Styled JSX, Tailwind CSS, Global CSS, Styled-components

Q25: Dynamic imports in Next.js
Using next/dynamic for lazy loading components
const Component = dynamic(() => import('../Components'));

Q26: Environment variables in Next.js
Use .env.local, access with process.env.NEXT_PUBLIC_... for client-side.

Q27: Optimize performance
Use Image component, code-splitting, caching, getStaticProps, lazy loading, CDN.

Q28: suspense and fallback
React Suspense allows components to wait for async data
and show a fallback UI (like a loader) while waiting.
import { Suspense } from "react";
import Users from "./Users";
export default function Page() {
  return (
    <div>
      <h2>Dashboard</h2>
      <Suspense fallback={<p>Loading users...</p>}>
        <Users />
      </Suspense>
    </div>
  );
}

Q29: app folder structure
app/
 ├─ layout.jsx             // Root layout for all pages
 ├─ page.jsx               // Home page 
 ├─ loading.jsx            // Default loading 
 ├─ error.jsx              // Global error boundary
 ├─ not-found.jsx          // Custom 404 page
 │
 ├─ users/
 │   ├─ page.jsx           // Route: /users
 │   ├─ [id]/page.jsx      // Dynamic Route: /users/1
 │   ├─ loading.jsx        //  loader
 │   ├─ error.jsx          //  error handler
 │
 ├─ components/
 │   ├─ Header.jsx
 │   ├─ Footer.jsx
 │   └─ Breadcrumb.jsx
 │
 ├─ lib/
 │   └─ fetchData.js       
 │
 ├─ styles/
 │   └─ globals.css
 |   └─ mixin.module.scss
 │
 └─ api/                   
     └─ users/route.js

Q30:All Route Handlers (Next.js App Router)
Used inside app/api/route.js (or [route]/route.js)
GET read and fetch data
POST create data
PUT  Update full data
PATCH update partial data
DELETE  remove data