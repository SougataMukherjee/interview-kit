==============================
REACT THEORY NOTES 
==============================

Q1: What is Virtual DOM?How React Manages Virtual DOM?
Virtual DOM is a lightweight JavaScript copy of the Real DOM.
React doesn't update the browser DOM directly. It updates the Virtual DOM first, compares it with the old one, and then updates only the changed parts in the Real DOM — which makes it fast
          User Action (e.g., button click)
                        ↓
               React creates New Virtual DOM
                        ↓
         Compare with Old Virtual DOM (Diffing)
                        ↓
       Update only changed part in Real DOM (Fast)


Q2: What is Reconciliation?
 The diffing process where React compares old and new virtual DOM trees and updates only changed parts.

How diffing algorithm works in Virtual DOM
 React compares old and new virtual DOM trees, updates only changed nodes (O(n) optimization).

Q3: Functional vs Class Components
 Functional - simpler, uses hooks.
 Class - uses lifecycle methods, more boilerplate.

Q4: What are Hooks in React?
 Functions that let you use React features without classes (e.g. useState, useEffect, useMemo, useCallback).

Q5: Explain useState
 Manages local state in functional components.
Example:
const [count, setCount] = useState(0);

Q6: Explain useEffect
 Performs side effects after render.(API calls, event, etc)
Example:
useEffect(() => { console.log('runs after render'); }, []);

Q6: Lifecycle using useEffect
useEffect(()=>{console.log("Mount")},[]); // Mount
useEffect(()=>{console.log("Update")},[val]); // Update
useEffect(()=>()=>console.log("Unmount"),[]); // Unmount

Q7: useMemo vs useCallback
useMemo → memoizes computed value
exp 1.
const [count, setCount] = useState(0);
  const double = useMemo(() => {
    console.log("Calculating...");
    return count * 2;
  }, [count]);
exp 2.
 const total = useMemo(() => {
    let sum = 0;
    for (let i = 0; i < arr.length; i++) {
      sum += arr[i];
    }
    return sum;
  }, [arr]);

useCallback → memoizes/caches function reference
const [count, setCount] = useState(0);
  const handleClick = useCallback(() => {
    setCount(c => c + 1);
  }, []);


Q8: What is Prop Drilling?
 Passing props deeply through multiple components. Solved using Context API.

Q9: What is Context API?
 Provides global state without prop drilling and solution for props drilling.
Example:
const UserContext = createContext();

Q10: What is React.memo?
 Prevents unnecessary re-renders of functional components when props don’t change.

Q11: Controlled vs Uncontrolled Components
Controlled - state managed by React.
Uncontrolled - managed by DOM via refs.

Q12: What is useRef?
 Used to access DOM elements or persist mutable values without re-render.
Example:
const inputRef = useRef();
-When do you need to use refs?
To directly access DOM elements or React elements.
Use case: focus input, play video, integrate 3rd-party lib.

Q13: Explain React Fiber
 Internal engine for scheduling rendering tasks efficiently.

Q14: Difference between keys in React list
 Unique key helps React identify elements and track updates efficiently.

Q15: Lifecycle methods in class component
Mounting → Component is created and added to the UI ,it runs once after initial render
          best for api calls,setting timers
Updating → Component re-renders when state/props change, it runs after every update
          Used to react to state/prop changes (e.g., data refresh)
Unmounting → Component is removed from the UI,Runs before component is destroyed its use for cleanup(clear timers, remove event listeners)
             Mounting     →     Updating     →     Unmounting
 (componentDidMount)  (componentDidUpdate)  (componentWillUnmount)

componentDidMount vs useEffect
componentDidMount (class) = runs once after mount.
componentDidMount() → Used only once in a class component; runs after the component is mounted.
useEffect(()=>{},[]) (hook) = same behavior in functional components.
useEffect() → Used in functional components; you can have multiple useEffect hooks for different side effects, and control when they run using dependency arrays

Q16: What is HOC (Higher Order Component)? why we use?
 A Higher-Order Component (HOC) is a function that takes a component as input and returns a new enhanced component with extra features (without modifying the original component).
 To reuse logic across multiple components (e.g., authentication check, logging, theme, APIs).
 HOC = Component → Enhanced Component


Q17: What is React Fragment?
<></> wrapper to avoid adding extra DOM nodes.

Q18: Error boundaries and limitation
Error Boundaries are special React components that catch runtime errors in child components and show a fallback UI instead of breaking the whole app.
They catch UI rendering errors, but not event handler errors and errors in asynchronous code(like setTimeout,fetch)

Q19. how to handle error in react?
class ErrorBoundary extends React.Component {
  state = { hasError: false };
  componentDidCatch() { this.setState({ hasError: true }); }
  render() {
    return this.state.hasError ? <h3>Something went wrong</h3> : this.props.children;
  }
}
and use like <ErrorBoundary><MyComponent/></ErrorBoundary>


Q19: Difference between state and props
State - internal, mutable(can modify), use for dynamic data.
Props - external, immutable, use for passing data to child components.
Parent Component (holds props/state)
        |
        |  passes data (props)
        ▼
 Child Component (receives props only)


Q20: How does React handle events?
Through synthetic events, which wrap native events for cross-browser compatibility.
Virtual DOM → In-memory copy of real DOM for faster UI diff & updates.
SPA (Single Page App) → One HTML loaded once; updates view via JS routing.
Babel → JS compiler that converts modern JS/JSX → browser-compatible code.
HOC (Higher-Order Component) → Function that takes a component and returns a new one with extra features.

Code-split / Lazy-load → Load parts of app only when needed for better performance
import("./math").then(math => {
  console.log(math.add(16, 20)); 
});

Q21. Route & Protected Route
Route: Defines which page or component should render for a specific URL path.
Protected Route: A route that only allows access if the user is authenticated (e.g., logged-in).
If not logged in → redirect to login page
User → Clicks /dashboard
         │
         ▼
   Is user logged in?
     /           \
    No            Yes
    ▼             ▼
 Redirect → /login   Show Dashboard Page


Q22. Render Props
Share logic by passing a function as a prop that returns JSX.
<Data render={(data) => <List data={data}/>}/>

Q23.React.createElement vs React.cloneElement
createElement: Creates a new element.
function Greeting({ name }) {
  return React.createElement(
    'h1',
    { className: 'greeting' },
    'Hello'
  );
}
cloneElement: Copies an element and adds new props/children.

Q24. Event-driven Architecture
Code reacts to events (e.g., click, message).
Microfrontend Architecture
Break big app into small independent frontends.

Q25.Types of API Calls
GET (read), POST (create), PUT/PATCH (update), DELETE (remove).

Q26.Type Checking with PropTypes
import PropTypes from 'prop-types';
Comp.propTypes = { name: PropTypes.string.isRequired };

Q27. React 18 Features
  1.Automatic Batching:Combines multiple state updates into one render.
  fetch('/api').then(()=>{
 setA(1); setB(2); setC(3); // only 1 re-render
});
  2.Transitions:Used for non-urgent updates
  import { startTransition } from 'react';
startTransition(() => setPage('home'));

Q28: Render Props
Share logic between components using function prop
<Data render={data => <List data={data}/>}/>

Q29: Axios
Axios is a promise-based HTTP client used to make API calls from browser
It helps send GET, POST, PUT, DELETE requests easily.
axios.get('/users');
axios.post('/users',{name:'Sam'});
axios.put('/user/1',{name:'A'});
axios.delete('/user/1');
Client (React / Next.js / Node)
        |
        |  Axios Request
        v
---------------------------------
|           Server API          |
|  (Handles DB, Auth, Logic)    |
---------------------------------
        ^
        |  Response (JSON)
        |
   Back to Client UI


Q30: Library vs Framework
Library: you control flow (React)
Framework: it controls flow (Angular)

Q31: React vs React DOM
React → core logic
ReactDOM → renders UI in browser

Q32: JSX
JS + HTML
const el = <h1>Hello {name}</h1>;

Q33:How do you print falsy values in JSX?
 Wrap in {String(value)} or conditional render.{String(false)}  // prints "false"

Q34.Is it possible to use React without JSX?
 Yes.
 React.createElement('h1', null, 'Hello');

Q35:How JSX prevents Injection Attacks?
 JSX escapes values before rendering → prevents XSS.
 <div>{userInput}</div> // safe

Q36: Props vs State
Props: read-only
State: mutable (internal data)

Q37: types of conditional rendering
isLogged ? <Home/> : <Login/>
status && <Loader/>
msg || "No message"

Q38: Folder Structure
React: src/components, hooks, pages, utils
Next.js: app/, pages/, components/, public/

Q39: Purpose of forwardRef?
Pass ref from parent → child component.
const Input = React.forwardRef((props, ref) => <input ref={ref} />);

Q40. What is Suspense component?
 Used to show fallback UI while loading async content (like lazy components).
<Suspense fallback={<p>Loading...</p>}> <MyComp /> </Suspense>

Q41. How to prevent component from rendering?
Return null inside render.
if(!isVisible) return null;

Q42. What are portals in React?
Render children outside parent DOM hierarchy.
ReactDOM.createPortal(child, domNode);

Q43. Why not call setState in componentWillUnmount()?
Component already unmounted → causes memory leak warning.

Q44. Is constructor mandatory in React class component?
No. Only needed when using this.state or binding methods.

Q45. How do you pass arguments to event handler?
 Use arrow function.
 onClick={() => handleClick(id)}




==============================
NEXT.JS THEORY NOTES 
==============================

Q1: What is Next.js?
 A React framework for server-side rendering, static site generation, and optimized performance.

Q2: CSR vs SSR vs SSG
CSR - Rendered on client (useEffect),its render in browser for fast navigation
SSR - Rendered on server per request (getServerSideProps),Render on server before sending HTML (better SEO)
SSG - Pre-built HTML at build time (getStaticProps)

Q3: Explain getStaticProps
getStaticProps is used for Static Site Generation (SSG) in Next.js.
It runs only at build time and generates static HTML, making the page fast.
Use it when data rarely changes (e.g., blogs, docs, product list)

Build Time → Fetch Data → Pre-render Page → Static HTML Served

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/users');
  const users = await res.json();
  return {
    props: { users }, // passed to the component
  };
}

export default function Users({ users }) {
  return (
    <div>
      <h2>User List</h2>
      {users.map(u => (
        <p key={u.id}>{u.name}</p>
      ))}
    </div>
  );
}

Q4: Explain getServerSideProps
getServerSideProps runs on the server for every request, fetches data, and sends it to the page before rendering.
When to use:
Data must be fresh on each page load (e.g., dashboard, user profile, stock price, weather, admin pages).
benefit:
No client-side fetch needed
Runs on every request (not cached)
SEO-friendly because content comes ready from server

export async function getServerSideProps() {
  const res = await fetch("https://api.example.com/data");
  const data = await res.json();

  return { props: { data } };
}

export default function Page({ data }) {
  return <pre>{JSON.stringify(data, null, 2)}</pre>;
}


Q5: Explain getStaticPaths
getStaticPaths is used in Next.js with dynamic routes to tell Next.js which dynamic pages to pre-build at build time.
Used together with getStaticProps for Static Site Generation (SSG).
why:
When a page has a dynamic route like /posts/[id]
We want only some specific pages to generate at build time
Improves performance by serving pre-rendered HTML

export async function getStaticPaths() {
  return {
    paths: [
      { params: { id: "1" } },
      { params: { id: "2" } }
    ],
    fallback: false
  };
}

export async function getStaticProps({ params }) {
  return {
    props: {
      id: params.id
    }
  };
}

export default function Post({ id }) {
  return <h2>Post Number: {id}</h2>;
}


Q6: Difference between pages and app router
- Pages router: uses /pages directory, older version.
- App router: introduced in Next.js 13, uses /app directory, server components, and layout.js.

Q7: What are Server Components?
Components rendered on the server — faster, smaller bundles, no client JS needed.

Q8: What are Client Components?
Components rendered in the browser using "use client" directive.

Q9: How to create API routes in Next.js?
Create serverless functions inside /pages/api or /app/api folder each file becomes an API endpoint.
Example:
export default function handler(req, res) { res.json({ msg: 'Hello' }) }

Q10: Difference between next/link and a tag
 next/link does client-side routing (faster, no reload), <a> tag reloads the page.

Q11: What is Image Optimization in Next.js?
 <Image /> automatically optimizes image size and format for performance.
 it Resizes large images to the size needed by the device,Lazy-loads images,Serves responsive images with srcset
 import Image from "next/image";
 <Image
        src="/images/profile.jpg"
        alt="Profile"
        width={300}
        height={300}
        quality={80}
        priority
      />

Q12: What is Middleware in Next.js?
Middleware runs before a request is completed. It can check the request and decide to allow, block, redirect, or rewrite the user before reaching a page or API.
why:
Authentication / Protect routes
Redirect users based on role or login
Request → Middleware → (Allow / Redirect / Rewrite / Block) → Page/API Route
in middleware.ts file write logic in next js

Q13: How to handle environment variables in Next.js?
 Stored in .env.local and accessed via process.env.NAME

Q14: What is ISR (Incremental Static Regeneration)?
 Allows static pages to update at runtime after a set interval (revalidate).
 Why use:
To keep content fresh (like blogs or product pages) while still using fast static generation.
export async function getStaticProps() {
  const data = await fetchData();
  return {
    props: { data },
    revalidate: 60, // re-build this page every 60 sec
  };
}


Q15: What is next/head used for?
 To modify <head> tags dynamically (title, meta tags).it improve SEO and Custom scripts like Google Analytics
 import Head from "next/head";
<Head>
    <title>My Portfolio</title>
    <meta name="description" content="Frontend Developer in Bangalore" />
    <meta property="og:title" content="Portfolio Site" />
</Head>

Q16: What is next/script?
 Used to control script loading strategy (lazyOnload, beforeInteractive, etc.).it will load script only when needed to improve performance.
<Script
        src="https://www.googletagmanager.com/gtag/js?id=GA_TRACKING_ID"
        strategy="afterInteractive"
      />

Q17: How to handle API fetching in Next.js 13 app router?
 Use async server components with fetch directly inside component.

Q18: What is Dynamic Routing in Next.js?
 File-based routing with parameters using [id].js files.
// pages/users/[id].js
import { useRouter } from "next/router";

export default function User() {
  const router = useRouter();
  const { id } = router.query; // get dynamic value from URL
  return <h1>User ID: {id}</h1>;
}

Q19: What are Layouts and Templates in Next.js 13?
Layouts persist between routes; templates re-render on navigation.
Layouts = Common UI (like Navbar/Footer).
Templates = Predefined page structures reused across routes.
export default function HomeLayout({ children }) {
  return (
    <div className="structure">
      <Header />
      <main>{children}</main>
      <Footer />
    </div>
  );
}

Q20: all route and folder Next.js app?
dynamic route [segment] → For routes like /user/[id], dynamic by parameter.
optional catch-all [...segment] → Matches /a, /a/b, /a/b/c.
optional [ [ ...segment ] ] → Same but optional (works with or without param).
private folder (folder) → Grouping folder not part of route path.
underscore _folder → Conventionally means internal folder (ignored by Next).

Q21: Styled JSX in Next.js
Built-in CSS-in-JS for component-level styling using <style jsx> tag.

Q22: How to improve SEO
Use SSR/SSG, meta tags, sitemap, semantic HTML, image alt, clean URLs.

Q23: Optimized data fetching (getStaticProps)
Yes getStaticProps pre-renders pages at build time for faster load.

Q24: Types of styling in Next.js
CSS Modules, Styled JSX, Tailwind CSS, Global CSS, Styled-components

Q25: Dynamic imports in Next.js
Using next/dynamic for lazy loading components
const Component = dynamic(() => import('../Components'));

Q26: Environment variables in Next.js
Use .env.local, access with process.env.NEXT_PUBLIC_... for client-side.

Q27: Optimize performance
Use Image component, code-splitting, caching, getStaticProps, lazy loading, CDN.

Q28: suspense and fallback
React Suspense allows components to wait for async data
and show a fallback UI (like a loader) while waiting.
import { Suspense } from "react";
import Users from "./Users";
export default function Page() {
  return (
    <div>
      <h2>Dashboard</h2>
      <Suspense fallback={<p>Loading users...</p>}>
        <Users />
      </Suspense>
    </div>
  );
}

Q29: app folder structure
app/
 ├─ layout.jsx             // Root layout for all pages
 ├─ page.jsx               // Home page 
 ├─ loading.jsx            // Default loading 
 ├─ error.jsx              // Global error boundary
 ├─ not-found.jsx          // Custom 404 page
 │
 ├─ users/
 │   ├─ page.jsx           // Route: /users
 │   ├─ [id]/page.jsx      // Dynamic Route: /users/1
 │   ├─ loading.jsx        //  loader
 │   ├─ error.jsx          //  error handler
 │
 ├─ components/
 │   ├─ Header.jsx
 │   ├─ Footer.jsx
 │   └─ Breadcrumb.jsx
 │
 ├─ lib/
 │   └─ fetchData.js       
 │
 ├─ styles/
 │   └─ globals.css
 |   └─ mixin.module.scss
 │
 └─ api/                   
     └─ users/route.js

Q30:All Route Handlers (Next.js App Router)
Used inside app/api/route.js (or [route]/route.js)
GET read and fetch data
POST create data
PUT  Update full data
PATCH update partial data
DELETE  remove data