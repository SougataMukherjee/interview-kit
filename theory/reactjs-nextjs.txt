==============================
REACT THEORY NOTES 
==============================

Q1: What is Virtual DOM?How React Manages Virtual DOM?
A: A lightweight JS representation of the real DOM. React updates only changed nodes, improving performance.
React keeps a virtual copy of the DOM → compares (diff) → updates only changed parts.

Q2: What is Reconciliation?
A: The diffing process where React compares old and new virtual DOM trees and updates only changed parts.

How diffing algorithm works in Virtual DOM
→ React compares old and new virtual DOM trees, updates only changed nodes (O(n) optimization).

Q3: Functional vs Class Components
A: Functional - simpler, uses hooks.
   Class - uses lifecycle methods, more boilerplate.

Q4: What are Hooks in React?
A: Functions that let you use React features without classes (e.g. useState, useEffect, useMemo, useCallback).

Q5: Explain useState
A: Manages local state in functional components.
Example:
const [count, setCount] = useState(0);

Q6: Explain useEffect
A: Performs side effects after render.(API calls, event, etc)
Example:
useEffect(() => { console.log('runs after render'); }, []);

Q6: Lifecycle using useEffect
useEffect(()=>{console.log("Mount")},[]); // Mount
useEffect(()=>{console.log("Update")},[val]); // Update
useEffect(()=>()=>console.log("Unmount"),[]); // Unmount


Q7: useMemo vs useCallback
A:
useMemo → memoizes computed value
const [count, setCount] = useState(0);

  const double = useMemo(() => {
    console.log("Calculating...");
    return count * 2;
  }, [count]);
useCallback → memoizes/caches function reference
const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    setCount(c => c + 1);
  }, []);


Q8: What is Prop Drilling?
A: Passing props deeply through multiple components. Solved using Context API.

Q9: What is Context API?
A: Provides global state without prop drilling and solution for props drilling.
Example:
const UserContext = createContext();

Q10: What is React.memo?
A: Prevents unnecessary re-renders of functional components when props don’t change.

Q11: Controlled vs Uncontrolled Components
A:
Controlled - state managed by React.
Uncontrolled - managed by DOM via refs.

Q12: What is useRef?
A: Used to access DOM elements or persist mutable values without re-render.
Example:
const inputRef = useRef();
When do you need to use refs?
To directly access DOM elements or React elements.
Use case: focus input, play video, integrate 3rd-party lib.

Q13: Explain React Fiber
A: Internal engine for scheduling rendering tasks efficiently.

Q14: Difference between keys in React list
A: Unique key helps React identify elements and track updates efficiently.

Q15: Lifecycle methods in class component
A:
Mounting → componentDidMount
Updating → componentDidUpdate
Unmounting → componentWillUnmount

componentDidMount vs useEffect
componentDidMount (class) = runs once after mount.
useEffect(()=>{},[]) (hook) = same behavior in functional components.

Q16: What is HOC (Higher Order Component)?
A: A function that takes a component and returns a new component with added functionality.

Q17: What is React Fragment?
A: <></> wrapper to avoid adding extra DOM nodes.

Q18: Error boundaries and limitation
A: Components that catch JS errors in child tree and display fallback UI.
but Error Boundaries cannot catch:
     Errors inside event handlers.
     Errors in asynchronous code(like setTimeout,fetch)

Q19. how to handle error in react?
class ErrorBoundary extends React.Component {
  state = { hasError: false };
  componentDidCatch() { this.setState({ hasError: true }); }
  render() {
    return this.state.hasError ? <h3>Something went wrong</h3> : this.props.children;
  }
}

and use like <ErrorBoundary><MyComponent/></ErrorBoundary>


Q19: Difference between state and props
A:
State - internal, mutable.
Props - external, immutable.

Q20: How does React handle events?
A: Through synthetic events, which wrap native events for cross-browser compatibility.
Virtual DOM → In-memory copy of real DOM for faster UI diff & updates.

SPA (Single Page App) → One HTML loaded once; updates view via JS routing.

Babel → JS compiler that converts modern JS/JSX → browser-compatible code.
HOC (Higher-Order Component) → Function that takes a component and returns a new one with extra features.

Code-split / Lazy-load → Load parts of app only when needed for better performance
import("./math").then(math => {
  console.log(math.add(16, 20)); 
});

Q21. Route & Protected Route
Route: Defines which component to show for a path.
Protected Route: Restricts access (e.g. only logged-in users).

Q22. Render Props
Share logic by passing a function as a prop that returns JSX.
<Data render={(data) => <List data={data}/>}/>

Q23.React.createElement vs React.cloneElement
createElement: Creates a new element.
function Greeting({ name }) {
  return React.createElement(
    'h1',
    { className: 'greeting' },
    'Hello'
  );
}
cloneElement: Copies an element and adds new props/children.

Q24. Event-driven Architecture
Code reacts to events (e.g., click, message).
Microfrontend Architecture
Break big app into small independent frontends.

Q25.Types of API Calls
GET (read), POST (create), PUT/PATCH (update), DELETE (remove).

Q26.Type Checking with PropTypes
import PropTypes from 'prop-types';
Comp.propTypes = { name: PropTypes.string.isRequired };

Q27. React 18 Features
  1.Automatic Batching:Combines multiple state updates into one render.
  fetch('/api').then(()=>{
 setA(1); setB(2); setC(3); // only 1 re-render
});
  2.Transitions:Used for non-urgent updates
  import { startTransition } from 'react';
startTransition(() => setPage('home'));

Q28: Render Props
Share logic between components using function prop
<Data render={data => <List data={data}/>}/>

Q29: Axios
axios.get('/users');
axios.post('/users',{name:'Sam'});
axios.put('/user/1',{name:'A'});
axios.delete('/user/1');

Library vs Framework
Library: you control flow (React)
Framework: it controls flow (Angular)

React vs React DOM
React → core logic
ReactDOM → renders UI in browser

JSX
JS + HTML
const el = <h1>Hello {name}</h1>;

How do you print falsy values in JSX?
 Wrap in {String(value)} or conditional render.{String(false)}  // prints "false"

 Is it possible to use React without JSX?
 Yes.
 React.createElement('h1', null, 'Hello');

How JSX prevents Injection Attacks?
 JSX escapes values before rendering → prevents XSS.
 <div>{userInput}</div> // safe


Props vs State

Props: read-only
State: mutable (internal data)

types of conditional rendering
isLogged ? <Home/> : <Login/>
status && <Loader/>
msg || "No message"

Folder Structure

React: src/components, hooks, pages, utils
Next.js: app/, pages/, components/, public/

Purpose of forwardRef?
Pass ref from parent → child component.
const Input = React.forwardRef((props, ref) => <input ref={ref} />);

What is Suspense component?
 Used to show fallback UI while loading async content (like lazy components).
<Suspense fallback={<p>Loading...</p>}> <MyComp /> </Suspense>

How to prevent component from rendering?
Return null inside render.
if(!isVisible) return null;

What are portals in React?
Render children outside parent DOM hierarchy.
ReactDOM.createPortal(child, domNode);

Why not call setState in componentWillUnmount()?
Component already unmounted → causes memory leak warning.

Is constructor mandatory in React class component?
No. Only needed when using this.state or binding methods.

How do you pass arguments to event handler?
 Use arrow function.
 onClick={() => handleClick(id)}




==============================
NEXT.JS THEORY NOTES 
==============================

Q1: What is Next.js?
A: A React framework for server-side rendering, static site generation, and optimized performance.

Q2: CSR vs SSR vs SSG
A:
CSR - Rendered on client (useEffect)
SSR - Rendered on server per request (getServerSideProps)
SSG - Pre-built HTML at build time (getStaticProps)

Q3: Explain getStaticProps
A: Used for static generation; runs at build time and provides props to page.

Q4: Explain getServerSideProps
A: Runs on each request; fetches data on server before rendering.

Q5: Explain getStaticPaths
A: Used with dynamic routes to pre-render specific paths at build time.

Q6: Difference between pages and app router
A:
- Pages router: uses /pages directory, older version.
- App router: introduced in Next.js 13, uses /app directory, server components, and layout.js.

Q7: What are Server Components?
A: Components rendered on the server — faster, smaller bundles, no client JS needed.

Q8: What are Client Components?
A: Components rendered in the browser using "use client" directive.

Q9: How to create API routes in Next.js?
A: Create serverless functions inside /pages/api or /app/api folder each file becomes an API endpoint.
Example:
export default function handler(req, res) { res.json({ msg: 'Hello' }) }

Q10: Difference between next/link and a tag
A: next/link does client-side routing (faster, no reload), <a> tag reloads the page.

Q11: What is Image Optimization in Next.js?
A: <Image /> automatically optimizes image size and format for performance.

Q12: What is Middleware in Next.js?
A: Runs before request is completed, used for auth, redirects, or rewrites.

Q13: How to handle environment variables in Next.js?
A: Stored in .env.local and accessed via process.env.NAME

Q14: What is ISR (Incremental Static Regeneration)?
A: Allows static pages to update at runtime after a set interval (revalidate).

Q15: What is next/head used for?
A: To modify <head> tags dynamically (title, meta tags).

Q16: What is next/script?
A: Used to control script loading strategy (lazyOnload, beforeInteractive, etc.).

Q17: How to handle API fetching in Next.js 13 app router?
A: Use async server components with fetch directly inside component.

Q18: What is Dynamic Routing in Next.js?
A: File-based routing with parameters using [id].js files.

Q19: What are Layouts and Templates in Next.js 13?
A: Layouts persist between routes; templates re-render on navigation.

Q20: How to deploy Next.js app?
A: Vercel (recommended), or Node server with next build + next start.
dynamic route [segment] → For routes like /user/[id], dynamic by parameter.
optional catch-all [...segment] → Matches /a, /a/b, /a/b/c.
optional [ [ ...segment ] ] → Same but optional (works with or without param).

private folder (folder) → Grouping folder not part of route path.
underscore _folder → Conventionally means internal folder (ignored by Next).

Styled JSX in Next.js
Built-in CSS-in-JS for component-level styling using <style jsx> tag.

Client-side vs Server-side Rendering
CSR: Render in browser (fast navigation).
SSR: Render on server before sending HTML (better SEO).

How to improve SEO
Use SSR/SSG, meta tags, sitemap, semantic HTML, image alt, clean URLs.

Layouts and Templates
 Layouts = Common UI (like Navbar/Footer).
 Templates = Predefined page structures reused across routes.

Optimized data fetching (getStaticProps)
Yes getStaticProps pre-renders pages at build time for faster load.

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/users');
  const users = await res.json();

  return {
    props: { users }, // passed to the component
  };
}

export default function Users({ users }) {
  return (
    <div>
      <h2>User List</h2>
      {users.map(u => (
        <p key={u.id}>{u.name}</p>
      ))}
    </div>
  );
}


Types of styling in Next.js
CSS Modules, Styled JSX, Tailwind CSS, Global CSS, Styled-components

Dynamic imports in Next.js
Using next/dynamic for lazy loading components
const Component = dynamic(() => import('../Components'));

Environment variables in Next.js
Use .env.local, access with process.env.NEXT_PUBLIC_... for client-side.

Optimize performance
Use Image component, code-splitting, caching, getStaticProps, lazy loading, CDN.

Dynamic Props in Next.js
// pages/users/[id].js
export async function getStaticPaths() {
  const res = await fetch('https://jsonplaceholder.typicode.com/users');
  const users = await res.json();

  const paths = users.map(user => ({
    params: { id: user.id.toString() }
  }));

  return { paths, fallback: false };
}

export async function getStaticProps({ params }) {
  const res = await fetch(`https://jsonplaceholder.typicode.com/users/${params.id}`);
  const user = await res.json();

  return { props: { user } };
}

export default function User({ user }) {
  return <h2>{user.name}</h2>;
}
